import com.sun.xml.internal.ws.policy.privateutil.PolicyUtils;import java.io.*;import java.util.*;/** * Created by Windows 10 on 1/19/2018. */public class Utils {    static ArrayList<Edge> sort(int i, ArrayList<Edge> edges, int N) {        switch (i) {            case 1:                return insertionSort(edges);            case 2:                return mergeSort(edges, 0, edges.size() - 1);            case 3:                return bubbleSort(edges);            case 4:                return optimumInsSort(edges, N, 0, edges.size() - 1);            case 5:                return optimumBubsort(edges, N, 0, edges.size() - 1);            default:                return quickSort(edges, 0, edges.size() - 1);        }    }    static public ArrayList<Edge> iterativeQsort(ArrayList<Edge> arr) {        Stack<Integer> stack = new Stack<>();        stack.push(0);        stack.push(arr.size());        while (!stack.isEmpty()) {            int end = stack.pop();            int start = stack.pop();            if (end - start < 2) continue;            int p = start + ((end - start) / 2);            p = partition(arr, p, start, end);            stack.push(p + 1);            stack.push(end);            stack.push(start);            stack.push(p);        }        return arr;    }    private static int partition(ArrayList<Edge> arr, int p, int start, int end) {        int l = start;        int h = end - 2;        int piv = arr.get(p).c;        interChang(arr, p, end - 1);        while (l < h) {            if (arr.get(l).c < piv) {                l++;            } else if (arr.get(h).c >= piv) {                h--;            } else {                interChang(arr, l, h);            }        }        int idx = h;        if (arr.get(h).c < piv) idx++;        interChang(arr, end - 1, idx);        return idx;    }    static ArrayList<Edge> quickSort(ArrayList<Edge> edges, final int left, final int right) {        if (left < right) {            int i = left;            int j = right + 1;            int pivot = edges.get(left).c;            do {                do i++; while (edges.get(i).c < pivot);                do j--; while (edges.get(j).c > pivot);                if (i < j)                    interChang(edges, i, j);            } while (i < j);            interChang(edges, left, j);            try {                quickSort(edges, left, j - 1);                quickSort(edges, j + 1, right);            } catch (StackOverflowError e) {            }        }        return edges;    }    private static ArrayList<Edge> insertionSort(ArrayList<Edge> edges) {        Edge minVal = new Edge(new Vertex(0), new Vertex(0));        minVal.c = 0;        edges.add(0, minVal);        for (int i = 2; i < edges.size(); i++) {            insert(edges.get(i), edges, i - 1);        }        edges.remove(0);        return edges;    }    private static ArrayList<Edge> mergeSort(ArrayList<Edge> edges, int left, int right) {        if (left < right) {            int middle = (left + right) / 2;            edges = mergeSort(edges, left, middle);            edges = mergeSort(edges, middle + 1, right);            edges = merge(edges, left, middle, right);        }        return edges;    }    private static ArrayList<Edge> bubbleSort(ArrayList<Edge> edges) {        for (int i = 0; i < edges.size(); i++)            for (int j = 1; j < edges.size() - i; j++) {                if (edges.get(j - 1).c > edges.get(j).c) {                    edges.set(j - 1, edges.set(j, edges.get(j - 1)));                }            }        return edges;    }    private static ArrayList<Edge> optimumInsSort(ArrayList<Edge> edges, int N, int left, int right) {        if (right - left > N) {            int i = left;            int j = right + 1;            int pivot = edges.get(left).c;            do {                do i++; while (edges.get(i).c < pivot);                do j--; while (edges.get(j).c > pivot);                if (i < j)                    interChang(edges, i, j);            } while (i < j);            interChang(edges, left, j);            optimumInsSort(edges, N, left, j - 1);            optimumInsSort(edges, N, j + 1, right);        } else {            ArrayList<Edge> subArray = new ArrayList();            for (int i = left; i <= right; i++)                subArray.add(edges.get(i));            subArray = insertionSort(subArray);            for (int i = left; i <= right; i++)                edges.set(i, subArray.get(i - left));        }        return edges;    }    private static ArrayList<Edge> optimumBubsort(ArrayList<Edge> edges, int N, int left, int right) {        if (right - left < N) {            int i = left;            int j = right + 1;            int pivot = edges.get(left).c;            do {                do i++; while (edges.get(i).c < pivot);                do j--; while (edges.get(j).c > pivot);                if (i < j)                    interChang(edges, i, j);            } while (i < j);            interChang(edges, left, j);            optimumBubsort(edges, left, j - 1, N);            optimumBubsort(edges, j + 1, right, N);        } else {            ArrayList<Edge> subArray = new ArrayList();            for (int i = left; i <= right; i++)                subArray.add(edges.get(i));            subArray = bubbleSort(subArray);            for (int i = left; i <= right; i++)                edges.set(i, subArray.get(i - left));        }        return edges;    }    static ArrayList readFile(String address) {        BufferedReader br = null;        FileReader fr = null;        ArrayList edges = new ArrayList<Integer>();        try {            fr = new FileReader(address);            br = new BufferedReader(fr);            String line = br.readLine();            while (line != null) {                String[] lines = line.split("\t");                edges.add(Integer.parseInt(lines[0]));                edges.add(Integer.parseInt(lines[1]));                line = br.readLine();            }        } catch (IOException e) {            e.printStackTrace();        } finally {            try {                if (br != null)                    br.close();                if (fr != null)                    fr.close();            } catch (IOException ex) {                ex.printStackTrace();            }        }        return edges;    }    static void interChang(ArrayList<Edge> list, int i, int j) {        list.set(j, list.set(i, list.get(j)));    }    static void insert(Edge e, ArrayList<Edge> edges, int i) {        while (e.c < edges.get(i).c) {            edges.set(i + 1, edges.get(i));            i--;        }        edges.set(i + 1, e);    }    static int findSize(ArrayList<Integer> edges) {        int max = 0;        for (Integer vertex : edges)            if (vertex > max)                max = vertex;        return max;    }    static ArrayList<Edge> merge(ArrayList<Edge> edges, int left, int middle, int right) {        ArrayList<Edge> helper = new ArrayList<>();        for (int i = left; i <= right; i++)            helper.add(edges.get(i));        int i = 0;        int j = middle - left + 1;        int k = left;        while (i <= middle - left && j <= right - left) {            if (helper.get(i).c < helper.get(j).c) {                edges.set(k, helper.get(i));                i++;            } else {                edges.set(k, helper.get(j));                j++;            }            k++;        }        while (i <= middle - left) {            edges.set(k, helper.get(i));            k++;            i++;        }        return edges;    }    static void writeToFile(boolean[] visited) throws IOException {        File fout = new File("result.txt");        FileOutputStream fos = new FileOutputStream(fout);        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(fos));        for (int i = 0; i < visited.length; i++) {            if (visited[i]) {                bw.write((i +1) + "");                bw.write(" A");                bw.newLine();            }            else {                bw.write((i +1)+ "");                bw.write(" B");                bw.newLine();            }        }        bw.close();    }}